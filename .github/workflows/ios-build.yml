name: Build iOS App

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-ios:
    name: Build & Sign iOS App
    runs-on: macos-latest
    
    steps:
      - name: Checkout Source
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Build Next.js App
        run: |
          rm -rf src/app/api
          rm -rf src/app/sitemap.xml
          npm run build
        env:
          NEXT_PUBLIC_EXPORT_MODE: 'true'
          NEXT_PUBLIC_BASE_URL: 'https://voxlo.app'
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

      - name: Setup Capacitor
        run: |
          npx cap sync ios
          # Force Manual signing in the project file
          sed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' ios/App/App.xcodeproj/project.pbxproj

      - name: Install Apple Certificate
        env:
          P12_BASE64: ${{ secrets.IOS_P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
          PROVISION_PROFILE_BASE64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
          KEYCHAIN_PASSWORD: ${{ github.run_id }}
        run: |
          set -euo pipefail

          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PROVISION_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Validate secrets
          if [ -z "$P12_BASE64" ]; then
            echo "::error::IOS_P12_BASE64 secret is empty"
            exit 1
          fi
          if [ -z "$PROVISION_PROFILE_BASE64" ]; then
            echo "::error::IOS_PROVISION_PROFILE_BASE64 secret is empty"
            exit 1
          fi

          # Decode base64 secrets
          echo "$P12_BASE64" | tr -d '[:space:]' | base64 -D > "$CERTIFICATE_PATH"
          echo "$PROVISION_PROFILE_BASE64" | tr -d '[:space:]' | base64 -D > "$PROVISION_PATH"

          # Verify decoded files
          CERT_SIZE=$(wc -c < "$CERTIFICATE_PATH" | tr -d ' ')
          PROV_SIZE=$(wc -c < "$PROVISION_PATH" | tr -d ' ')
          echo "Certificate: $CERT_SIZE bytes"
          echo "Provisioning Profile: $PROV_SIZE bytes"

          if [ "$CERT_SIZE" -lt 100 ]; then
            echo "::error::Certificate file too small ($CERT_SIZE bytes)"
            exit 1
          fi
          if [ "$PROV_SIZE" -lt 100 ]; then
            echo "::error::Provisioning profile file too small ($PROV_SIZE bytes)"
            exit 1
          fi

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate (suppress verbose output)
          security import "$CERTIFICATE_PATH" -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH" 2>&1 | grep -v "^    " || true
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" 2>/dev/null
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          echo "Certificate imported successfully"

          # Extract plist from PKCS#7 envelope using openssl (more reliable than security cms)
          DECODED_PLIST="$RUNNER_TEMP/profile.plist"

          # Method 1: openssl smime
          if openssl smime -inform der -verify -noverify -in "$PROVISION_PATH" -out "$DECODED_PLIST" 2>/dev/null; then
            echo "Decoded profile using openssl smime"
          # Method 2: openssl cms
          elif openssl cms -inform der -verify -noverify -in "$PROVISION_PATH" -out "$DECODED_PLIST" 2>/dev/null; then
            echo "Decoded profile using openssl cms"
          # Method 3: security cms
          elif security cms -D -i "$PROVISION_PATH" -o "$DECODED_PLIST" 2>/dev/null; then
            echo "Decoded profile using security cms"
          # Method 4: Extract XML directly by finding start/end markers
          else
            echo "Trying direct XML extraction..."
            # Find byte offset of <?xml and </plist>, extract that range
            START=$(grep -abo '<?xml' "$PROVISION_PATH" | head -1 | cut -d: -f1)
            END=$(grep -abo '</plist>' "$PROVISION_PATH" | tail -1 | cut -d: -f1)
            if [ -n "$START" ] && [ -n "$END" ]; then
              # Add 8 for </plist> length
              LEN=$((END - START + 8))
              dd if="$PROVISION_PATH" bs=1 skip="$START" count="$LEN" of="$DECODED_PLIST" 2>/dev/null
              echo "Extracted plist using dd (offset $START, length $LEN)"
            fi
          fi

          # Final fallback: if still no valid file, try strings + sed
          if [ ! -s "$DECODED_PLIST" ] || ! head -c 5 "$DECODED_PLIST" | grep -q '<?xml'; then
            echo "Trying strings extraction..."
            strings "$PROVISION_PATH" | sed -n '/<?xml/,/<\/plist>/p' > "$DECODED_PLIST"
            echo "Extracted plist using strings"
          fi

          # Verify we got valid XML
          if [ ! -s "$DECODED_PLIST" ]; then
            echo "::error::All extraction methods failed - no output file"
            xxd -l 64 "$PROVISION_PATH"
            exit 1
          fi

          if ! head -c 10 "$DECODED_PLIST" | grep -q '<?xml'; then
            echo "::error::Decoded file is not valid XML plist"
            echo "First 100 bytes of decoded file:"
            xxd -l 100 "$DECODED_PLIST"
            exit 1
          fi

          echo "Plist extraction successful"

          # Extract UUID from decoded plist using PlistBuddy
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$DECODED_PLIST")
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" "$DECODED_PLIST")

          if [ -z "$PROFILE_UUID" ]; then
            echo "::error::UUID not found in provisioning profile"
            exit 1
          fi

          echo "UUID: $PROFILE_UUID"
          echo "Name: $PROFILE_NAME"
          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_ENV

          # Install profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp "$PROVISION_PATH" ~/Library/MobileDevice/Provisioning\ Profiles/${PROFILE_UUID}.mobileprovision
          echo "Profile installed: ${PROFILE_UUID} (${PROFILE_NAME})"

      - name: Build iOS App
        run: |
          cd ios/App
          xcodebuild -project App.xcodeproj \
            -scheme App \
            -sdk iphoneos \
            -configuration Release \
            -archivePath $RUNNER_TEMP/App.xcarchive \
            archive \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM=5TPBNT392A \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE="${{ env.PROFILE_UUID }}" \
            PROVISIONING_PROFILE_SPECIFIER="" \
            PRODUCT_BUNDLE_IDENTIFIER="app.voxlo" \
            AD_HOC_CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=YES \
            CODE_SIGNING_ALLOWED=YES

      - name: Export IPA
        run: |
          cd ios/App
          cat > $RUNNER_TEMP/ExportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>app-store-connect</string>
            <key>teamID</key>
            <string>5TPBNT392A</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>app.voxlo</key>
              <string>${{ env.PROFILE_UUID }}</string>
            </dict>
          </dict>
          </plist>
          EOF
          
          xcodebuild -exportArchive \
            -archivePath $RUNNER_TEMP/App.xcarchive \
            -exportOptionsPlist $RUNNER_TEMP/ExportOptions.plist \
            -exportPath $RUNNER_TEMP/export

      - name: Upload IPA Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Voxlo-iOS
          path: ${{ runner.temp }}/export/*.ipa

      - name: Cleanup Keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
